{
  "examples": {
    "count-min-appearances": {
      "metadata": {
        "dataDependency": "Sequential",
        "codePattern": "Concatenation",
        "repetition": "None"
      },
      "title": "Count Min Appearances",
      "prompt": "Given a list of N integers, output the number of appearances of the minimum.",
      "patterns": "min, counting",
      "explanation": "In this example, the two loops have been refactored into separate functions to improve readability and maintainability. The first function finds the minimum value, while the second counts occurrences of that minimum value.",
      
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nmin = nums[0]\nfor num in nums:\n  if min > num:\n    min = num\ncounter = 0\nfor num in nums:\n  if min == num:\n    counter += 1\nreturn counter"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nmin = findmin(nums)\ncount = countmatches(nums, min)\nreturn count\n\ndef findmin(nums):\n  min = nums[0]\n  for num in nums:\n    if min > num:\n      min = num\n  return min\n\ndef countmatches(nums, val):\n  counter = 0\n  for num in nums:\n    if val == num:\n      counter += 1\n  return counter"
      },
      "highlights": [
        {
          "pattern": "min = findmin(nums)",
          "class": "highlight-orange"
        },
        {
          "pattern": "count = countmatches(nums, min)",
          "class": "highlight-orange"
        },
        {
          "pattern": "def findmin(nums):",
          "class": "highlight-blue"
        },
        {
          "pattern": "def countmatches(nums, val):",
          "class": "highlight-orange"
        }
      ]
    },
    "find-min-max": {
      "title": "Find Min and Max",
      "prompt": "Given a list of N integers, output both the minimum and maximum values.",
      "patterns": "min, max, extremum",
      "explanation": "This example demonstrates finding both minimum and maximum values in a single pass through the data, then refactoring into separate functions for better modularity.",
      "metadata": {
        "dataDependency": "None",
        "codePattern": "Concatenation",
        "repetition": "Identical"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nmin_val = nums[0]\nmax_val = nums[0]\nfor num in nums:\n  if min_val > num:\n    min_val = num\n  if max_val < num:\n    max_val = num\nreturn min_val, max_val"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nmin_val = findmin(nums)\nmax_val = findmax(nums)\nreturn min_val, max_val\n\ndef findmin(nums):\n  min_val = nums[0]\n  for num in nums:\n    if min_val > num:\n      min_val = num\n  return min_val\n\ndef findmax(nums):\n  max_val = nums[0]\n  for num in nums:\n    if max_val < num:\n      max_val = num\n  return max_val"
      },
      "highlights": [
        {
          "pattern": "min_val = findmin(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "max_val = findmax(nums)",
          "class": "highlight-green"
        },
        {
          "pattern": "def findmin(nums):",
          "class": "highlight-blue"
        },
        {
          "pattern": "def findmax(nums):",
          "class": "highlight-green"
        }
      ]
    },
    "sum-and-average": {
      "title": "Sum and Average",
      "prompt": "Given a list of N integers, calculate both the sum and average.",
      "patterns": "accumulation, arithmetic",
      "explanation": "This example shows two operations sharing the same data. Both sum and average need to process all elements, demonstrating shared data dependency.",
      "metadata": {
        "dataDependency": "Shared",
        "codePattern": "Concatenation",
        "repetition": "None"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\ntotal = 0\nfor num in nums:\n  total += num\naverage = total / len(nums)\nreturn total, average"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\ntotal = calculate_sum(nums)\naverage = calculate_average(nums)\nreturn total, average\n\ndef calculate_sum(nums):\n  total = 0\n  for num in nums:\n    total += num\n  return total\n\ndef calculate_average(nums):\n  return calculate_sum(nums) / len(nums)"
      },
      "highlights": [
        {
          "pattern": "total = calculate_sum(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "average = calculate_average(nums)",
          "class": "highlight-green"
        },
        {
          "pattern": "def calculate_sum(nums):",
          "class": "highlight-blue"
        },
        {
          "pattern": "def calculate_average(nums):",
          "class": "highlight-green"
        }
      ]
    },
    "filter-positive-negative": {
      "title": "Filter Positive and Negative",
      "prompt": "Given a list of N integers, separate them into positive and negative numbers.",
      "patterns": "filtering, classification",
      "explanation": "This demonstrates non-sequential data dependency where elements are categorized independently but results are collected separately.",
      "metadata": {
        "dataDependency": "Non-sequential",
        "codePattern": "Inclusion",
        "repetition": "None"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\npositive = []\nnegative = []\nfor num in nums:\n  if num > 0:\n    positive.append(num)\n  elif num < 0:\n    negative.append(num)\nreturn positive, negative"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\npositive = filter_positive(nums)\nnegative = filter_negative(nums)\nreturn positive, negative\n\ndef filter_positive(nums):\n  result = []\n  for num in nums:\n    if num > 0:\n      result.append(num)\n  return result\n\ndef filter_negative(nums):\n  result = []\n  for num in nums:\n    if num < 0:\n      result.append(num)\n  return result"
      },
      "highlights": [
        {
          "pattern": "positive = filter_positive(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "negative = filter_negative(nums)",
          "class": "highlight-orange"
        },
        {
          "pattern": "def filter_positive(nums):",
          "class": "highlight-blue"
        },
        {
          "pattern": "def filter_negative(nums):",
          "class": "highlight-orange"
        }
      ]
    },
    "find-all-occurrences": {
      "title": "Find All Occurrences",
      "prompt": "Given a list of N integers and a target value, find all indices where the target appears.",
      "patterns": "searching, indexing",
      "explanation": "This shows identical repetition where the same search logic is applied to find multiple occurrences.",
      "metadata": {
        "dataDependency": "None",
        "codePattern": "Concatenation",
        "repetition": "Identical"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums, target)\nindices = []\nfor i in range(len(nums)):\n  if nums[i] == target:\n    indices.append(i)\nreturn indices"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums, target)\nindices = find_indices(nums, target)\nreturn indices\n\ndef find_indices(nums, value):\n  result = []\n  for i in range(len(nums)):\n    if nums[i] == value:\n      result.append(i)\n  return result"
      },
      "highlights": [
        {
          "pattern": "indices = find_indices(nums, target)",
          "class": "highlight-blue"
        },
        {
          "pattern": "def find_indices(nums, value):",
          "class": "highlight-blue"
        }
      ]
    },
    "validate-and-process": {
      "title": "Validate and Process",
      "prompt": "Given a list of N integers, validate they are all positive, then calculate their product.",
      "patterns": "validation, transformation",
      "explanation": "Sequential dependency where validation must complete before processing can begin. The second operation depends on the first's result.",
      "metadata": {
        "dataDependency": "Sequential",
        "codePattern": "Inclusion",
        "repetition": "None"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nvalid = True\nfor num in nums:\n  if num <= 0:\n    valid = False\n    break\nif not valid:\n  return None\nproduct = 1\nfor num in nums:\n  product *= num\nreturn product"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nif not validate_positive(nums):\n  return None\nproduct = calculate_product(nums)\nreturn product\n\ndef validate_positive(nums):\n  for num in nums:\n    if num <= 0:\n      return False\n  return True\n\ndef calculate_product(nums):\n  product = 1\n  for num in nums:\n    product *= num\n  return product"
      },
      "highlights": [
        {
          "pattern": "if not validate_positive(nums):",
          "class": "highlight-orange"
        },
        {
          "pattern": "product = calculate_product(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "def validate_positive(nums):",
          "class": "highlight-orange"
        },
        {
          "pattern": "def calculate_product(nums):",
          "class": "highlight-blue"
        }
      ]
    },
    "count-evens-odds": {
      "title": "Count Evens and Odds",
      "prompt": "Given a list of N integers, count how many are even and how many are odd.",
      "patterns": "counting, classification",
      "explanation": "Demonstrates variable included repetition where similar counting logic is applied with different conditions.",
      "metadata": {
        "dataDependency": "Non-sequential",
        "codePattern": "Interleaved",
        "repetition": "Variable Included"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\neven_count = 0\nodd_count = 0\nfor num in nums:\n  if num % 2 == 0:\n    even_count += 1\n  else:\n    odd_count += 1\nreturn even_count, odd_count"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\neven_count = count_by_condition(nums, is_even)\nodd_count = count_by_condition(nums, is_odd)\nreturn even_count, odd_count\n\ndef count_by_condition(nums, condition):\n  count = 0\n  for num in nums:\n    if condition(num):\n      count += 1\n  return count\n\ndef is_even(num):\n  return num % 2 == 0\n\ndef is_odd(num):\n  return num % 2 != 0"
      },
      "highlights": [
        {
          "pattern": "even_count = count_by_condition(nums, is_even)",
          "class": "highlight-blue"
        },
        {
          "pattern": "odd_count = count_by_condition(nums, is_odd)",
          "class": "highlight-orange"
        },
        {
          "pattern": "def count_by_condition(nums, condition):",
          "class": "highlight-green"
        }
      ]
    },
    "scale-and-shift": {
      "title": "Scale and Shift Array",
      "prompt": "Given a list of N integers, multiply each by 2, then add 5 to each result.",
      "patterns": "transformation, mapping",
      "explanation": "Shows variable scaled repetition where transformations are applied at different scales or magnitudes.",
      "metadata": {
        "dataDependency": "Sequential",
        "codePattern": "Concatenation",
        "repetition": "Variable Scaled"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nscaled = []\nfor num in nums:\n  scaled.append(num * 2)\nshifted = []\nfor val in scaled:\n  shifted.append(val + 5)\nreturn shifted"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nscaled = scale_values(nums, 2)\nshifted = shift_values(scaled, 5)\nreturn shifted\n\ndef scale_values(nums, factor):\n  result = []\n  for num in nums:\n    result.append(num * factor)\n  return result\n\ndef shift_values(nums, offset):\n  result = []\n  for num in nums:\n    result.append(num + offset)\n  return result"
      },
      "highlights": [
        {
          "pattern": "scaled = scale_values(nums, 2)",
          "class": "highlight-blue"
        },
        {
          "pattern": "shifted = shift_values(scaled, 5)",
          "class": "highlight-orange"
        },
        {
          "pattern": "def scale_values(nums, factor):",
          "class": "highlight-blue"
        },
        {
          "pattern": "def shift_values(nums, offset):",
          "class": "highlight-orange"
        }
      ]
    },
    "merge-sorted-lists": {
      "title": "Merge Two Sorted Lists",
      "prompt": "Given two sorted lists, merge them into one sorted list.",
      "patterns": "merging, sorting",
      "explanation": "Interleaved pattern where elements from two sources are combined in an alternating fashion based on comparison.",
      "metadata": {
        "dataDependency": "Shared",
        "codePattern": "Interleaved",
        "repetition": "None"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(list1, list2)\nresult = []\ni = 0\nj = 0\nwhile i < len(list1) and j < len(list2):\n  if list1[i] <= list2[j]:\n    result.append(list1[i])\n    i += 1\n  else:\n    result.append(list2[j])\n    j += 1\nresult.extend(list1[i:])\nresult.extend(list2[j:])\nreturn result"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(list1, list2)\nmerged = merge_lists(list1, list2)\nreturn merged\n\ndef merge_lists(list1, list2):\n  result = []\n  i, j = 0, 0\n  while i < len(list1) and j < len(list2):\n    if list1[i] <= list2[j]:\n      result.append(list1[i])\n      i += 1\n    else:\n      result.append(list2[j])\n      j += 1\n  result.extend(list1[i:])\n  result.extend(list2[j:])\n  return result"
      },
      "highlights": [
        {
          "pattern": "merged = merge_lists(list1, list2)",
          "class": "highlight-blue"
        },
        {
          "pattern": "def merge_lists(list1, list2):",
          "class": "highlight-blue"
        }
      ]
    },
    "find-second-largest": {
      "title": "Find Second Largest",
      "prompt": "Given a list of N integers, find the second largest value.",
      "patterns": "extremum, comparison",
      "explanation": "Sequential dependency where finding the second largest requires knowing the largest value first.",
      "metadata": {
        "dataDependency": "Sequential",
        "codePattern": "Inclusion",
        "repetition": "Identical"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nmax_val = nums[0]\nsecond_max = nums[0]\nfor num in nums:\n  if num > max_val:\n    second_max = max_val\n    max_val = num\n  elif num > second_max and num != max_val:\n    second_max = num\nreturn second_max"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nsorted_unique = get_sorted_unique(nums)\nsecond_largest = sorted_unique[-2] if len(sorted_unique) >= 2 else None\nreturn second_largest\n\ndef get_sorted_unique(nums):\n  unique_nums = list(set(nums))\n  unique_nums.sort(reverse=True)\n  return unique_nums"
      },
      "highlights": [
        {
          "pattern": "sorted_unique = get_sorted_unique(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "def get_sorted_unique(nums):",
          "class": "highlight-blue"
        }
      ]
    },
    "normalize-data": {
      "title": "Normalize Data",
      "prompt": "Given a list of N integers, normalize them to range [0, 1].",
      "patterns": "normalization, scaling",
      "explanation": "Shows shared data dependency where min and max are needed by all normalization calculations. Variable scaled repetition applies the same formula with different values.",
      "metadata": {
        "dataDependency": "Shared",
        "codePattern": "Inclusion",
        "repetition": "Variable Scaled"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nmin_val = nums[0]\nmax_val = nums[0]\nfor num in nums:\n  if num < min_val:\n    min_val = num\n  if num > max_val:\n    max_val = num\nrange_val = max_val - min_val\nnormalized = []\nfor num in nums:\n  normalized.append((num - min_val) / range_val)\nreturn normalized"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nmin_val = find_min(nums)\nmax_val = find_max(nums)\nnormalized = normalize_values(nums, min_val, max_val)\nreturn normalized\n\ndef find_min(nums):\n  min_val = nums[0]\n  for num in nums:\n    if num < min_val:\n      min_val = num\n  return min_val\n\ndef find_max(nums):\n  max_val = nums[0]\n  for num in nums:\n    if num > max_val:\n      max_val = num\n  return max_val\n\ndef normalize_values(nums, min_val, max_val):\n  range_val = max_val - min_val\n  result = []\n  for num in nums:\n    result.append((num - min_val) / range_val)\n  return result"
      },
      "highlights": [
        {
          "pattern": "min_val = find_min(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "max_val = find_max(nums)",
          "class": "highlight-green"
        },
        {
          "pattern": "normalized = normalize_values(nums, min_val, max_val)",
          "class": "highlight-orange"
        }
      ]
    },
    "remove-duplicates": {
      "title": "Remove Duplicates",
      "prompt": "Given a list of N integers, remove all duplicate values while preserving order.",
      "patterns": "deduplication, filtering",
      "explanation": "Non-sequential dependency where each element is checked independently against previously seen values.",
      "metadata": {
        "dataDependency": "Non-sequential",
        "codePattern": "Concatenation",
        "repetition": "None"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums)\nseen = set()\nresult = []\nfor num in nums:\n  if num not in seen:\n    seen.add(num)\n    result.append(num)\nreturn result"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums)\nunique = get_unique_ordered(nums)\nreturn unique\n\ndef get_unique_ordered(nums):\n  seen = set()\n  result = []\n  for num in nums:\n    if num not in seen:\n      seen.add(num)\n      result.append(num)\n  return result"
      },
      "highlights": [
        {
          "pattern": "unique = get_unique_ordered(nums)",
          "class": "highlight-blue"
        },
        {
          "pattern": "def get_unique_ordered(nums):",
          "class": "highlight-blue"
        }
      ]
    },
    "partition-by-pivot": {
      "title": "Partition by Pivot",
      "prompt": "Given a list of N integers and a pivot value, partition into elements less than, equal to, and greater than the pivot.",
      "patterns": "partitioning, comparison",
      "explanation": "Interleaved pattern with variable included repetition where similar comparison logic produces three different outputs.",
      "metadata": {
        "dataDependency": "Non-sequential",
        "codePattern": "Interleaved",
        "repetition": "Variable Included"
      },
      "unrefactored": {
        "title": "Unrefactored",
        "code": "read(nums, pivot)\nless_than = []\nequal_to = []\ngreater_than = []\nfor num in nums:\n  if num < pivot:\n    less_than.append(num)\n  elif num == pivot:\n    equal_to.append(num)\n  else:\n    greater_than.append(num)\nreturn less_than, equal_to, greater_than"
      },
      "refactored": {
        "title": "Refactored",
        "code": "read(nums, pivot)\nless_than = filter_by_condition(nums, lambda x: x < pivot)\nequal_to = filter_by_condition(nums, lambda x: x == pivot)\ngreater_than = filter_by_condition(nums, lambda x: x > pivot)\nreturn less_than, equal_to, greater_than\n\ndef filter_by_condition(nums, condition):\n  result = []\n  for num in nums:\n    if condition(num):\n      result.append(num)\n  return result"
      },
      "highlights": [
        {
          "pattern": "less_than = filter_by_condition(nums, lambda x: x < pivot)",
          "class": "highlight-blue"
        },
        {
          "pattern": "equal_to = filter_by_condition(nums, lambda x: x == pivot)",
          "class": "highlight-orange"
        },
        {
          "pattern": "greater_than = filter_by_condition(nums, lambda x: x > pivot)",
          "class": "highlight-green"
        },
        {
          "pattern": "def filter_by_condition(nums, condition):",
          "class": "highlight-blue"
        }
      ]
    }
  }
}
